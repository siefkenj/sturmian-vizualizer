// Generated by CoffeeScript 1.4.0
/*
#Copyright (c) 2002-2013
#   Jason Siefken
#
#js-continuedfraction is free software: you can redistribute it and/or modify
#it under the terms of the GNU General Public License as published by
#the Free Software Foundation, either version 3 of the License, or
#(at your option) any later version.
#
#This program is distributed in the hope that it will be useful,
#but WITHOUT ANY WARRANTY; without even the implied warranty of
#MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#GNU General Public License for more details.
#
#You should have received a copy of the GNU General Public License
#along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/*
# Continued fraction library for javascript
*/

var ContinuedFraction, ExclusiveTimer, MathFunctions, TextAreaChangeTracker, createFragment, evaluateMath, inputbox, mathjs,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

ContinuedFraction = (function() {

  ContinuedFraction.prototype.MAX_CONTINUANT = 100000;

  function ContinuedFraction(val) {
    this.update(val);
  }

  ContinuedFraction.prototype.update = function(val) {
    if (val == null) {
      val = 0;
    }
    this.continuants = [];
    this.convergents = [];
    if (val instanceof Array) {
      this.continuants = val.slice();
    } else {
      this.continuants = this.continuantsFromNum(val);
    }
    this.computeConvergents();
    return this.value = this.computeValue();
  };

  ContinuedFraction.prototype.continuantsFromNum = function(num) {
    var i, ret, _i;
    ret = [];
    if (num >= 1) {
      ret.push(Math.floor(num));
      num -= Math.floor(num);
    } else {
      ret.push(0);
    }
    for (i = _i = 1; _i <= 30; i = ++_i) {
      i = Math.floor(1 / num);
      if (i > this.MAX_CONTINUANT) {
        break;
      }
      ret.push(i);
      num = 1 / num - i;
    }
    if (ret[ret.length - 1] === 1 && ret.length > 1) {
      ret[ret.length - 2] += 1;
      ret.length = ret.length - 1;
    }
    return ret;
  };

  ContinuedFraction.prototype.computeConvergents = function(n) {
    var i, p, pp, q, qq, tmpp, tmpq, _i, _ref;
    p = 1;
    q = 0;
    pp = 0;
    qq = 1;
    for (i = _i = 0, _ref = this.continuants.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      tmpp = p;
      tmpq = q;
      p = this.continuants[i] * p + pp;
      q = this.continuants[i] * q + qq;
      pp = tmpp;
      qq = tmpq;
      this.convergents.push([p, q]);
    }
  };

  ContinuedFraction.prototype.computeValue = function() {
    var approx;
    approx = this.convergents[this.convergents.length - 1];
    return approx[0] / approx[1];
  };

  ContinuedFraction.prototype.toLatex = function(maxLevels) {
    var toLatex;
    if (maxLevels == null) {
      maxLevels = Infinity;
    }
    toLatex = function(coeff) {
      var ret;
      if (coeff.length === 0) {
        return "";
      }
      if (coeff.length === 1) {
        return "" + coeff[0];
      }
      ret = "";
      if (coeff[0] !== 0) {
        ret += "" + coeff[0] + " + ";
      }
      ret += "\\cfrac{1}{";
      ret += toLatex(coeff.slice(1));
      ret += "}";
      return ret;
    };
    return toLatex(this.continuants.slice(0, maxLevels));
  };

  ContinuedFraction.prototype.toString = function() {
    var toString;
    toString = function(coeff) {
      var ret;
      if (coeff.length === 0) {
        return "";
      }
      if (coeff.length === 1) {
        return "" + coeff[0];
      }
      ret = "";
      if (coeff[0] !== 0) {
        ret += "" + coeff[0] + " + ";
      }
      ret += "1/(";
      ret += toLatex(coeff.slice(1));
      ret += ")";
      return ret;
    };
    return toString(this.continuants);
  };

  return ContinuedFraction;

})();

/*
# Synchronize input boxes to accept math input and update 
# the continued fraction object.
#
# Arguments:
#   decimalInput: the <input/> where you type a decimal number
#   continuedFractionInput: the <input/> where you type a cf comma separated list
#   updateCallback: the function to be called whenever the cf is changed
#   createInputs: bool specifying if you'd like <input/> to be created for you
# Returns: object with properties
#   fraction: the ContinuedFraction object
#   decimalInput: the <input/> for decimals or null
#   continuedFractionInput: the <input/> for cf or null
#   inputs: the parent element of the inputs or null
#   updateCallback: the function called whenever the cf is changed or null
*/


inputbox = function(ops) {
  var continuedFractionInput, continuedfractionTracker, decimalInput, decimalTracker, frac, inputs, ret, timer, updateCallback, updateFraction;
  if (ops == null) {
    ops = {};
  }
  decimalInput = ops.decimalInput, continuedFractionInput = ops.continuedFractionInput;
  if (typeof decimalInput === 'string') {
    decimalInput = document.querySelector(decimalInput);
  }
  if (typeof continuedFractionInput === 'string') {
    continuedFractionInput = document.querySelector(continuedFractionInput);
  }
  if (ops.createInputs) {
    inputs = createFragment("<div id=\"inputarea\">\n    <div class=\"inputblock\">\n        <label for=\"decimal\">Decimal:</label>\n        <input id=\"decimal\" name=\"decimal\" />\n    </div>\n    <div class=\"inputblock\">\n        <label for=\"continuedfraction\">Continued Fraction:</label>\n        <input id=\"continuedfraction\" name=\"continuedfraction\" />\n    </div>\n</div>");
    decimalInput = inputs.querySelector('#decimal');
    continuedFractionInput = inputs.querySelector('#continuedfraction');
  }
  updateCallback = ops.updateCallback;
  frac = new ContinuedFraction;
  updateFraction = function(inputType) {
    var v, values;
    switch (inputType) {
      case 'decimal':
        if (decimalInput) {
          frac.update(evaluateMath(decimalInput.value));
        }
        if (continuedFractionInput) {
          continuedFractionInput.value = frac.continuants;
        }
        break;
      case 'continuedfraction':
        if (continuedFractionInput) {
          values = evaluateMath(continuedFractionInput.value);
        }
        values = (function() {
          var _i, _len, _ref, _results;
          _ref = values || [];
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            v = _ref[_i];
            if (v != null) {
              _results.push(v);
            }
          }
          return _results;
        })();
        frac.update(values);
        if (decimalInput) {
          decimalInput.value = frac.value;
        }
    }
    return typeof updateCallback === "function" ? updateCallback(frac) : void 0;
  };
  timer = new ExclusiveTimer;
  if (decimalInput != null) {
    decimalTracker = new TextAreaChangeTracker(decimalInput);
    decimalTracker.change(function() {
      return timer.setTimeout(updateFraction, 250, 'decimal');
    });
  }
  if (continuedFractionInput) {
    continuedfractionTracker = new TextAreaChangeTracker(continuedFractionInput);
    continuedfractionTracker.change(function() {
      return timer.setTimeout(updateFraction, 250, 'continuedfraction');
    });
  }
  ret = {
    fraction: frac,
    decimalInput: decimalInput,
    continuedFractionInput: continuedFractionInput,
    updateCallback: updateCallback,
    inputs: inputs
  };
  return ret;
};

/*
# Creates an html fragment from the given string
*/


createFragment = function(str) {
  var div, frag;
  frag = document.createDocumentFragment();
  div = document.createElement('div');
  div.innerHTML = str;
  while (div.firstChild) {
    frag.appendChild(div.firstChild);
  }
  return frag;
};

/*
# ExclusiveTimer keeps a queue of all timeout
# callbacks, but only issues the most recent one.
# That is, if another callback request is added before the
# timer on the previous one runs out, only the new one is executed
# (when it's time has elapased) and the previous one is ignored.
*/


ExclusiveTimer = (function() {

  function ExclusiveTimer() {
    this.queue = [];
  }

  ExclusiveTimer.prototype.setTimeout = function(callback, delay, args) {
    var c, doCallback, myIndex, _i, _len, _ref,
      _this = this;
    if (args == null) {
      args = [];
    }
    if (!(args instanceof Array)) {
      args = [args];
    }
    _ref = this.queue;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      c = _ref[_i];
      c.execute = false;
    }
    myIndex = this.queue.length;
    this.queue.push({
      callback: callback,
      execute: true
    });
    doCallback = function() {
      var _ref1;
      if ((_ref1 = _this.queue[myIndex]) != null ? _ref1.execute : void 0) {
        _this.queue[myIndex].callback.apply(null, args);
        return _this.queue.length = 0;
      }
    };
    return window.setTimeout(doCallback, delay);
  };

  return ExclusiveTimer;

})();

/*
# Keep track of all changes to a particular textarea
# including ones that may happen on keyup, keydown, blur,
# etc.
*/


TextAreaChangeTracker = (function() {

  function TextAreaChangeTracker(textarea) {
    var event, _i, _len, _ref,
      _this = this;
    this.textarea = textarea;
    this._triggerIfChanged = __bind(this._triggerIfChanged, this);

    if (typeof this.textarea === 'string') {
      this.textarea = document.querySelector(this.textarea);
    }
    this.value = this.textarea.value;
    this.onchangeCallbacks = [];
    _ref = ['change', 'keydown', 'keypress', 'blur'];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      event = _ref[_i];
      this.textarea.addEventListener(event, (function() {
        return window.setTimeout(_this._triggerIfChanged, 100);
      }));
    }
  }

  TextAreaChangeTracker.prototype._triggerIfChanged = function() {
    var c, newVal, _i, _len, _ref, _results;
    newVal = this.textarea.value;
    if (newVal !== this.value) {
      this.value = newVal;
      _ref = this.onchangeCallbacks;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        c = _ref[_i];
        _results.push(c());
      }
      return _results;
    }
  };

  TextAreaChangeTracker.prototype.change = function(callback) {
    return this.onchangeCallbacks.push(callback);
  };

  return TextAreaChangeTracker;

})();

/*
# All the useful math functions
# Taken from graphit: https://github.com/siefkenj/graphit
*/


MathFunctions = {
  random: Math.random,
  tan: Math.tan,
  min: Math.min,
  PI: Math.PI,
  sqrt: Math.sqrt,
  E: Math.E,
  SQRT1_2: Math.SQRT1_2,
  ceil: Math.ceil,
  atan2: Math.atan2,
  cos: Math.cos,
  LN2: Math.LN2,
  LOG10E: Math.LOG10E,
  exp: Math.exp,
  round: function(n, places) {
    var shift;
    shift = Math.pow(10, places);
    return Math.round(n * shift) / shift;
  },
  atan: Math.atan,
  max: Math.max,
  pow: Math.pow,
  LOG2E: Math.LOG2E,
  log: Math.log,
  LN10: Math.LN10,
  floor: Math.floor,
  SQRT2: Math.SQRT2,
  asin: Math.asin,
  acos: Math.acos,
  sin: Math.sin,
  abs: Math.abs,
  cpi: "\u03C0",
  ctheta: "\u03B8",
  pi: Math.PI,
  phi: (1 + Math.sqrt(5)) / 2,
  ln: Math.log,
  e: Math.E,
  sign: function(x) {
    if (x === 0) {
      return 0;
    } else {
      if (x < 0) {
        return -1;
      } else {
        return 1;
      }
    }
  },
  arcsin: Math.asin,
  arccos: Math.acos,
  arctan: Math.atan,
  sinh: function(x) {
    return (Math.exp(x) - Math.exp(-x)) / 2;
  },
  cosh: function(x) {
    return (Math.exp(x) + Math.exp(-x)) / 2;
  },
  tanh: function(x) {
    return (Math.exp(x) - Math.exp(-x)) / (Math.exp(x) + Math.exp(-x));
  },
  arcsinh: function(x) {
    return ln(x + Math.sqrt(x * x + 1));
  },
  arccosh: function(x) {
    return ln(x + Math.sqrt(x * x - 1));
  },
  arctanh: function(x) {
    return ln((1 + x) / (1 - x)) / 2;
  },
  sech: function(x) {
    return 1 / cosh(x);
  },
  csch: function(x) {
    return 1 / sinh(x);
  },
  coth: function(x) {
    return 1 / tanh(x);
  },
  arcsech: function(x) {
    return arccosh(1 / x);
  },
  arccsch: function(x) {
    return arcsinh(1 / x);
  },
  arccoth: function(x) {
    return arctanh(1 / x);
  },
  sec: function(x) {
    return 1 / Math.cos(x);
  },
  csc: function(x) {
    return 1 / Math.sin(x);
  },
  cot: function(x) {
    return 1 / Math.tan(x);
  },
  arcsec: function(x) {
    return arccos(1 / x);
  },
  arccsc: function(x) {
    return arcsin(1 / x);
  },
  arccot: function(x) {
    return arctan(1 / x);
  }
};

evaluateMath = function(str) {
  var hasComma, i, l, t, tokens, _i, _len;
  hasComma = str.match(/,/);
  str = mathjs(str);
  tokens = str.split(/\b/);
  for (i = _i = 0, _len = tokens.length; _i < _len; i = ++_i) {
    t = tokens[i];
    if (t in MathFunctions) {
      tokens[i] = "MathFunctions." + t;
    }
  }
  str = tokens.join('');
  if (hasComma) {
    return (function() {
      var _j, _len1, _ref, _results;
      _ref = str.split(/,/);
      _results = [];
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        l = _ref[_j];
        _results.push(eval(l));
      }
      return _results;
    })();
  } else {
    return eval(str);
  }
};

/*
# The math pre-processor from asciiSvg
*/


mathjs = function(st) {
  var ch, i, j, k, nested;
  st = st.replace(/\s/g, "");
  if (st.indexOf("^-1") !== -1) {
    st = st.replace(/sin\^-1/g, "arcsin");
    st = st.replace(/cos\^-1/g, "arccos");
    st = st.replace(/tan\^-1/g, "arctan");
    st = st.replace(/sec\^-1/g, "arcsec");
    st = st.replace(/csc\^-1/g, "arccsc");
    st = st.replace(/cot\^-1/g, "arccot");
    st = st.replace(/sinh\^-1/g, "arcsinh");
    st = st.replace(/cosh\^-1/g, "arccosh");
    st = st.replace(/tanh\^-1/g, "arctanh");
    st = st.replace(/sech\^-1/g, "arcsech");
    st = st.replace(/csch\^-1/g, "arccsch");
    st = st.replace(/coth\^-1/g, "arccoth");
  }
  st = st.replace(/^e$/g, "(E)");
  st = st.replace(/^e([^a-zA-Z])/g, "(E)$1");
  st = st.replace(/([^a-zA-Z])e([^a-zA-Z])/g, "$1(E)$2");
  st = st.replace(/([0-9])([\(a-zA-Z])/g, "$1*$2");
  st = st.replace(/\)([\(0-9a-zA-Z])/g, ")*$1");
  i = void 0;
  j = void 0;
  k = void 0;
  ch = void 0;
  nested = void 0;
  while ((i = st.indexOf("^")) !== -1) {
    if (i === 0) {
      throw new Error("missing argument for '^'");
    }
    j = i - 1;
    ch = st.charAt(j);
    if (ch >= "0" && ch <= "9") {
      j--;
      while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
        j--;
      }
      if (ch === ".") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
          j--;
        }
      }
    } else if (ch === ")") {
      nested = 1;
      j--;
      while (j >= 0 && nested > 0) {
        ch = st.charAt(j);
        if (ch === "(") {
          nested--;
        } else {
          if (ch === ")") {
            nested++;
          }
        }
        j--;
      }
      while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
      }
    } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
      j--;
      while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
      }
    } else {
      throw new Error("incorrect syntax in " + st + " at position " + j);
    }
    if (i === st.length - 1) {
      throw new Error("missing argument");
    }
    k = i + 1;
    ch = st.charAt(k);
    if (ch >= "0" && ch <= "9" || ch === "-") {
      k++;
      while (k < st.length && (ch = st.charAt(k)) >= "0" && ch <= "9") {
        k++;
      }
      if (ch === ".") {
        k++;
        while (k < st.length && (ch = st.charAt(k)) >= "0" && ch <= "9") {
          k++;
        }
      }
    } else if (ch === "(") {
      nested = 1;
      k++;
      while (k < st.length && nested > 0) {
        ch = st.charAt(k);
        if (ch === "(") {
          nested++;
        } else {
          if (ch === ")") {
            nested--;
          }
        }
        k++;
      }
    } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
      k++;
      while (k < st.length && (ch = st.charAt(k)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        k++;
      }
    } else {
      throw new Error("incorrect syntax in " + st + " at position " + k);
    }
    st = st.slice(0, j + 1) + "pow(" + st.slice(j + 1, i) + "," + st.slice(i + 1, k) + ")" + st.slice(k);
  }
  while ((i = st.indexOf("!")) !== -1) {
    if (i === 0) {
      throw new Error("missing argument for '!'");
    }
    j = i - 1;
    ch = st.charAt(j);
    if (ch >= "0" && ch <= "9") {
      j--;
      while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
        j--;
      }
      if (ch === ".") {
        j--;
        while (j >= 0 && (ch = st.charAt(j)) >= "0" && ch <= "9") {
          j--;
        }
      }
    } else if (ch === ")") {
      nested = 1;
      j--;
      while (j >= 0 && nested > 0) {
        ch = st.charAt(j);
        if (ch === "(") {
          nested--;
        } else {
          if (ch === ")") {
            nested++;
          }
        }
        j--;
      }
      while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
      }
    } else if (ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
      j--;
      while (j >= 0 && (ch = st.charAt(j)) >= "a" && ch <= "z" || ch >= "A" && ch <= "Z") {
        j--;
      }
    } else {
      throw new Error("incorrect syntax in " + st + " at position " + j);
    }
    st = st.slice(0, j + 1) + "factorial(" + st.slice(j + 1, i) + ")" + st.slice(i + 1);
  }
  return st;
};

/*
# Add all our useful utilities as class methods
*/


ContinuedFraction.MathFunctions = MathFunctions;

ContinuedFraction.evaluateMath = evaluateMath;

ContinuedFraction.inputbox = inputbox;

window.ContinuedFraction = ContinuedFraction;
