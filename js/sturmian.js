// Generated by CoffeeScript 1.4.0
/*
# Class to give lots of info about a Sturmian sequence
*/

var SVGCircle, SeqView, SturmainSeq;

SturmainSeq = (function() {

  function SturmainSeq(theta, offset) {
    this.theta = theta;
    this.offset = offset != null ? offset : 0;
    if (!(this.theta instanceof ContinuedFraction)) {
      this.theta = new ContinuedFraction(this.theta);
    }
  }

  SturmainSeq.prototype.getDigits = function(n) {
    var i, ret, theta, x, _i;
    theta = this.theta.value;
    x = this.offset;
    ret = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      ret.push(Math.floor((i + 1) * theta + x) - Math.floor(i * theta + x));
    }
    return ret.join('');
  };

  SturmainSeq.prototype.largestLevelBelowLength = function(maxLen) {
    var maxIterations, p, q, _i, _len, _ref, _ref1;
    maxIterations = 0;
    _ref = this.theta.convergents;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], p = _ref1[0], q = _ref1[1];
      if (Math.abs(q) > maxLen) {
        break;
      }
      maxIterations += 1;
    }
    return maxIterations;
  };

  SturmainSeq.prototype.getLevels = function(maxLen) {
    var a, i, levels, maxIterations, newLevel, _i, _len, _ref;
    if (maxLen == null) {
      maxLen = 30;
    }
    levels = ['1', '0'];
    maxIterations = this.largestLevelBelowLength(maxLen) - 2;
    _ref = this.theta.continuants.slice(1);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      a = _ref[i];
      a = Math.abs(a);
      if (i > maxIterations) {
        break;
      }
      if (i === 0) {
        newLevel = Array(a).join(levels[i + 1]) + levels[i];
      } else {
        newLevel = Array(a + 1).join(levels[i + 1]) + levels[i];
      }
      levels.push(newLevel);
    }
    return levels;
  };

  SturmainSeq.prototype.getFormattedDigits = function(maxLen) {
    var a, i, levels, maxIterations, newLevel, _i, _len, _ref;
    if (maxLen == null) {
      maxLen = 30;
    }
    levels = ["<span level='0'>1</span>\u200b", "<span level='1'>0</span>\u200b"];
    maxIterations = this.largestLevelBelowLength(maxLen) - 2;
    _ref = this.theta.continuants.slice(1);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      a = _ref[i];
      a = Math.abs(a);
      if (i > maxIterations) {
        break;
      }
      if (i === 0) {
        newLevel = Array(a).join(levels[i + 1]) + levels[i];
      } else {
        newLevel = Array(a + 1).join(levels[i + 1]) + levels[i];
      }
      levels.push("<span level='" + (i + 2) + "'>" + newLevel + "</span>");
    }
    return levels[levels.length - 1];
  };

  return SturmainSeq;

})();

$(document).ready(function() {
  var DIGITS, cf, frac, sturm, updateCircleView, updateContinuedFraction, updateSeqView;
  $('#nav div').click(function(event) {
    var elm;
    elm = $(event.currentTarget);
    $('#displayarea [page]').hide();
    $(elm.attr('href')).show();
    $('#nav div').removeClass('selected');
    elm.addClass('selected');
    switch (elm.attr('href')) {
      case '#sequenceview':
        return updateSeqView(new ContinuedFraction(ContinuedFraction.evaluateMath($('#decimal').val())));
      case '#fractionview':
        return updateContinuedFraction(new ContinuedFraction(ContinuedFraction.evaluateMath($('#decimal').val())));
    }
  });
  window.seqView = new SeqView;
  cf = ContinuedFraction.inputbox({
    decimalInput: '#decimal',
    continuedFractionInput: '#continuedfraction',
    updateCallback: function(frac) {
      updateSeqView(frac);
      updateCircleView(frac);
      updateContinuedFraction(frac);
    }
  });
  frac = cf.frac;
  sturm = new SturmainSeq(frac);
  DIGITS = 500;
  updateSeqView = function(frac) {
    var elm, level, maxLevel, seq, _i, _len, _ref;
    seq = new SturmainSeq(frac);
    seqView.update(seq, DIGITS);
    maxLevel = seq.largestLevelBelowLength(DIGITS);
    _ref = $('#levelchooser li');
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      level = parseInt(elm.getAttribute('level'), 10);
      if (level < maxLevel) {
        $(elm).show();
      } else {
        $(elm).hide();
      }
    }
    return MathJax.Hub.Queue(["Typeset", MathJax.Hub, $('#levelshower')[0]]);
  };
  seqView.createLevelsView(sturm, DIGITS);
  seqView.createLevelsList(sturm, DIGITS);
  $('#sequence').html(seqView.prettySeq);
  $('#levelshower').html(seqView.levelsList);
  seqView.highlightLevel();
  $('#levelchooser li').click(function(evt) {
    var elm, level;
    elm = evt.currentTarget;
    level = parseInt(elm.getAttribute('level'), 10);
    seqView.highlightLevel(level);
    $('#levelchooser li').removeClass('selected');
    return $(elm).addClass('selected');
  });
  updateSeqView(new ContinuedFraction(ContinuedFraction.evaluateMath($('#decimal').val())));
  window.circle = new SVGCircle;
  $('#circlecontainer').append(circle.svg);
  $('#iterate').click(function() {
    return circle.drawNSteps(1);
  });
  $('#reset').click(function() {
    return circle.update(null, 0, 0);
  });
  updateCircleView = function(frac) {
    return circle.update(frac.value);
  };
  return updateContinuedFraction = function(frac) {
    var a, b, i, table, _i, _len, _ref, _ref1;
    table = $("<table></table>");
    _ref = frac.convergents.slice(0, 20);
    for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
      _ref1 = _ref[i], a = _ref1[0], b = _ref1[1];
      table.append("<tr>\n    <td>$\\displaystyle\\frac{p_{" + i + "}}{q_{" + i + "}} = \n    \\displaystyle\\frac{" + a + "}{" + b + "}$\n    <span class=\"approx\">$\\approx " + (a / b) + "$</span>\n    </td>\n</tr>");
    }
    $('#convergents .content').html(table);
    $('#prettyprinted .content').html("\\[" + (frac.toLatex(10)) + "\\]");
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, $('#continuants .content')[0]]);
  };
});

SeqView = (function() {

  function SeqView(sturm) {
    this.sturm = sturm;
  }

  SeqView.prototype.update = function(sturm, digits) {
    var oldLevelsList, oldPrettySeq;
    this.sturm = sturm;
    if (digits == null) {
      digits = 100;
    }
    oldPrettySeq = this.prettySeq;
    this.createLevelsView(this.sturm, digits);
    oldPrettySeq.replaceWith(this.prettySeq);
    oldLevelsList = this.levelsList;
    this.createLevelsList(this.sturm, digits);
    oldLevelsList.replaceWith(this.levelsList);
    if (this.previousHighlightLevel != null) {
      return this.highlightLevel(this.previousHighlightLevel);
    }
  };

  SeqView.prototype.createLevelsView = function(sturm, digits) {
    var seq;
    if (sturm == null) {
      sturm = this.sturm;
    }
    if (digits == null) {
      digits = 100;
    }
    seq = sturm.getFormattedDigits(digits);
    return this.prettySeq = $(seq);
  };

  SeqView.prototype.createLevelsList = function(sturm, digits) {
    var i, levels, s, view, _i, _len;
    if (sturm == null) {
      sturm = this.sturm;
    }
    if (digits == null) {
      digits = 100;
    }
    levels = sturm.getLevels(digits);
    view = $("<ul></ul>");
    for (i = _i = 0, _len = levels.length; _i < _len; i = ++_i) {
      s = levels[i];
      view.append("<li level='" + i + "'>${\\bf s}_{" + i + "}$ = " + s + "</li>");
    }
    return this.levelsList = view;
  };

  SeqView.prototype.highlightLevel = function(level) {
    var walk;
    if (level == null) {
      level = 1;
    }
    this.previousHighlightLevel = level;
    walk = function(parent, level) {
      var elm, l, _i, _len, _ref, _results;
      if (parseInt(parent.attr('level'), 10) === level) {
        parent.addClass('level1');
        return;
      }
      _ref = parent.children();
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elm = _ref[_i];
        elm = $(elm);
        l = parseInt(elm.attr('level'), 10);
        if (l > level) {
          walk(elm, level);
        }
        if (l === level) {
          elm.addClass('level1');
        }
        if (l === level - 1) {
          _results.push(elm.addClass('level0'));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };
    this.prettySeq.find('.level1').removeClass('level1');
    this.prettySeq.find('.level0').removeClass('level0');
    if (this.levelsList) {
      this.levelsList.find('.level1').removeClass('level1');
      this.levelsList.find('.level0').removeClass('level0');
      this.levelsList.find("[level=" + level + "]").addClass('level1');
      this.levelsList.find("[level=" + (level - 1) + "]").addClass('level0');
    }
    return walk(this.prettySeq, level);
  };

  return SeqView;

})();

SVGCircle = (function() {
  var addEasyAttrs, createElmNS;

  createElmNS = function(name, attrs, parent) {
    var NAMESPACE, elm, k, v;
    if (attrs == null) {
      attrs = {};
    }
    NAMESPACE = "http://www.w3.org/2000/svg";
    elm = document.createElementNS(NAMESPACE, name);
    if (name === 'svg') {
      elm.setAttribute('xmlns', NAMESPACE);
    }
    for (k in attrs) {
      v = attrs[k];
      elm.setAttribute(k, v);
    }
    if (parent != null) {
      parent.appendChild(elm);
    }
    return addEasyAttrs(elm);
  };

  addEasyAttrs = function(elm) {
    elm.attr = function(attr) {
      var name, ret, val, _i, _len, _ref;
      if (!(attr != null)) {
        ret = {};
        _ref = elm.attributes;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          attr = _ref[_i];
          ret[attr.name] = attr.value;
        }
        return ret;
      }
      if (typeof attr === 'string') {
        return elm.getAttribute(attr);
      }
      for (name in attr) {
        val = attr[name];
        elm.setAttribute(name, val);
      }
      return elm;
    };
    return elm;
  };

  function SVGCircle(theta, offset) {
    var circle, end, flag, i, label, labelPos, newDigit, p, pos, q, start;
    this.theta = theta != null ? theta : 1 / (3 + 1 / (2 + 1 / 7.54154354));
    this.offset = offset != null ? offset : 0;
    this.unmoddedOffset = this.offset;
    this.thetaCont = new ContinuedFraction(this.theta);
    this.numsteps = 0;
    this.tickLens = (function() {
      var _i, _len, _ref, _ref1, _results;
      _ref = this.thetaCont.convergents;
      _results = [];
      for (i = _i = 0, _len = _ref.length; _i < _len; i = ++_i) {
        _ref1 = _ref[i], p = _ref1[0], q = _ref1[1];
        _results.push([q, 15 / Math.sqrt(i + 1)]);
      }
      return _results;
    }).call(this);
    this.svg = createElmNS('svg');
    this.svg.attr({
      width: 400,
      height: 400
    });
    this.width = 400;
    this.height = 400;
    this.defs = createElmNS('defs', {}, this.svg);
    this.style = createElmNS('style', {
      type: 'text/css'
    }, this.defs);
    this.style.textContent = ".thetaback {\n        fill: rgba(45, 188, 255, 0.54);\n}\n.thetaline {\n        stroke: #06F;\n}\n.marker {\n        fill: #0014F8;\n        stroke: rgba(255, 255, 255, 0.72);\n        stroke-width: 2;\n}\n.seq {\n        font-family: sans-serif;\n        font-size: 20;\n}\n.thetatext {\n        font-family: serif;\n        font-size: 40;\n}";
    this.radius = 300 / 2;
    this.displayGroup = createElmNS('g', {
      transform: "translate(" + (this.width / 2) + "," + (this.height / 2) + ")"
    }, this.svg);
    this.ticksList = [];
    circle = createElmNS('circle', {
      r: this.radius,
      fill: 'none',
      stroke: 'black'
    }, this.displayGroup);
    start = this.toCircleCoords(0);
    end = this.toCircleCoords(this.theta);
    flag = this.theta < .5 ? 0 : 1;
    this.thetaHighlight = createElmNS('path', {
      d: "M" + start + " A " + this.radius + " " + this.radius + " 0 " + flag + " 0 " + end + " L 0 0 Z",
      stroke: 'none',
      fill: 'lightblue',
      'class': 'thetaback'
    }, this.displayGroup);
    this.thetaWedge = createElmNS('path', {
      d: "M" + start + " A " + this.radius + " " + this.radius + " 0 " + flag + " 0 " + end,
      stroke: 'blue',
      fill: 'none',
      'stroke-width': 3,
      'class': 'thetaline'
    }, this.displayGroup);
    labelPos = [-Math.sin(2 * Math.PI * this.theta / 2) * 20, -Math.cos(2 * Math.PI * this.theta / 2) * 20];
    label = createElmNS('text', {
      x: labelPos[0],
      y: labelPos[1] + 5,
      'font-size': 40,
      'text-anchor': 'middle',
      'class': 'thetatext'
    }, this.displayGroup);
    label.textContent = '\u03b8';
    pos = this.toCircleCoords(this.offset);
    this.offsetMarker = createElmNS('circle', {
      r: 5,
      cx: "0",
      cy: "" + (-this.radius),
      transform: "rotate(-" + (this.offset * 360) + ")",
      stroke: 'none',
      fill: 'black',
      'class': 'marker'
    }, this.displayGroup);
    window.c = this.offsetMarker;
    this.seq = createElmNS('text', {
      x: 20,
      y: 30,
      'class': 'seq',
      'font-size': 20
    }, this.svg);
    newDigit = this.offset < this.theta ? 1 : 0;
    this.newDigit(newDigit);
  }

  SVGCircle.prototype.update = function(theta, offset, numsteps) {
    var elm, end, flag, start, _i, _len, _ref;
    if (theta == null) {
      theta = this.theta;
    }
    this.offset = offset != null ? offset : 0;
    this.theta = theta;
    this.thetaCont = new ContinuedFraction(this.theta);
    if (!(numsteps != null)) {
      numsteps = this.numsteps;
    }
    this.numsteps = 0;
    _ref = this.ticksList;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      elm = _ref[_i];
      $(elm).remove();
    }
    start = this.toCircleCoords(0);
    end = this.toCircleCoords(this.theta);
    flag = this.theta < .5 ? 0 : 1;
    this.thetaHighlight.attr({
      d: "M" + start + " A " + this.radius + " " + this.radius + " 0 " + flag + " 0 " + end + " L 0 0 Z"
    });
    this.thetaWedge.attr({
      d: "M" + start + " A " + this.radius + " " + this.radius + " 0 " + flag + " 0 " + end
    });
    return this.drawNSteps(numsteps, {
      animate: false
    });
  };

  SVGCircle.prototype.toCircleCoords = function(angle) {
    var x, y;
    x = -Math.sin(2 * Math.PI * angle);
    y = Math.cos(2 * Math.PI * angle);
    return [this.radius * x, -this.radius * y];
  };

  SVGCircle.prototype.radialTick = function(angle, length) {
    var x, y;
    if (length == null) {
      length = 15;
    }
    x = -Math.sin(2 * Math.PI * angle);
    y = Math.cos(2 * Math.PI * angle);
    return [[x * (this.radius + length / 2), -y * (this.radius + length / 2)], [x * (this.radius - length / 2), -y * (this.radius - length / 2)]];
  };

  SVGCircle.prototype.drawNSteps = function(n, ops) {
    var digits, i, l, oldOffset, path, q, tick, tickLen, _i, _j, _len, _ref, _ref1,
      _this = this;
    if (n == null) {
      n = 1;
    }
    if (ops == null) {
      ops = {
        animate: true
      };
    }
    this.numsteps += n;
    tickLen = 20;
    _ref = this.tickLens;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], q = _ref1[0], l = _ref1[1];
      if (this.numsteps <= q + 1) {
        tickLen = l;
        break;
      }
    }
    oldOffset = this.offset;
    path = "";
    for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
      this.offset = (this.offset + this.theta) % 1;
      this.unmoddedOffset = this.unmoddedOffset + this.theta;
      tick = this.radialTick(this.offset, tickLen);
      path += "M " + tick[0] + " L " + tick[1] + " ";
    }
    this.ticksList.push(createElmNS('path', {
      d: path,
      stroke: 'black'
    }, this.displayGroup));
    digits = (new SturmainSeq(this.theta)).getDigits(this.numsteps);
    if (ops.animate) {
      this.animComplete = function() {
        return _this.seq.textContent = digits;
      };
      return this.animateRotation(oldOffset, this.offset);
    } else {
      this.offsetMarker.attr({
        transform: "rotate(" + (-this.offset * 360) + ")"
      });
      return this.seq.textContent = digits;
    }
  };

  SVGCircle.prototype.drawNextStep = function(ops) {
    var l, newDigit, q, tick, tickLen, _i, _len, _ref, _ref1;
    if (ops == null) {
      ops = {
        animate: true
      };
    }
    this.numsteps += 1;
    tickLen = 20;
    _ref = this.tickLens;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      _ref1 = _ref[_i], q = _ref1[0], l = _ref1[1];
      if (this.numsteps <= q + 1) {
        tickLen = l;
        break;
      }
    }
    tick = this.radialTick(this.offset, tickLen);
    createElmNS('line', {
      x1: tick[0][0],
      y1: tick[0][1],
      x2: tick[1][0],
      y2: tick[1][1],
      stroke: 'black'
    }, this.displayGroup);
    this.offset = (this.offset + this.theta) % 1;
    this.unmoddedOffset = this.unmoddedOffset + this.theta;
    if (ops.animate) {
      return this.animateRotation(this.unmoddedOffset - this.theta, this.unmoddedOffset, 250, 30);
    } else {
      this.offsetMarker.attr({
        transform: "rotate(-" + (this.unmoddedOffset * 360) + ")"
      });
      newDigit = this.offset < this.theta ? 1 : 0;
      return this.newDigit(newDigit);
    }
  };

  SVGCircle.prototype.animateRotation = function(from, to, duration, frames) {
    var backwardDist, delay, e, easing, easingFunc, forwardDist, i, update,
      _this = this;
    if (from == null) {
      from = 0;
    }
    if (to == null) {
      to = 1;
    }
    if (duration == null) {
      duration = 1000;
    }
    if (frames == null) {
      frames = 60;
    }
    easingFunc = function(x) {
      return x * x;
    };
    to = (1 + (to % 1)) % 1;
    from = (1 + (from % 1)) % 1;
    forwardDist = Math.abs(to - from);
    backwardDist = 1 - forwardDist;
    if (forwardDist > backwardDist) {
      from = to - backwardDist;
    }
    easing = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= frames ? _i <= frames : _i >= frames; i = 0 <= frames ? ++_i : --_i) {
        _results.push(easingFunc(i / frames));
      }
      return _results;
    })();
    easing = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = easing.length; _i < _len; _i++) {
        e = easing[_i];
        _results.push(from + (to - from) * e);
      }
      return _results;
    })();
    delay = Math.floor(duration / frames);
    i = 0;
    update = function() {
      var _, _i, _results;
      if (i < frames) {
        _this.offsetMarker.attr({
          transform: "rotate(" + (-easing[i] * 360) + ")"
        });
        i += 1;
        window.setTimeout(update, delay);
        return;
      }
      if (i === frames) {
        _this.offsetMarker.attr({
          transform: "rotate(" + (-to * 360) + ")"
        });
        _results = [];
        for (_ = _i = 0; _i <= 10; _ = ++_i) {
          _results.push(typeof _this.animComplete === "function" ? _this.animComplete() : void 0);
        }
        return _results;
      }
    };
    return window.setTimeout(update, 0);
  };

  SVGCircle.prototype.newDigit = function(d) {
    return this.seq.textContent = this.seq.textContent + d;
  };

  return SVGCircle;

})();
